### 前端基础面试

#### 计算机和浏览器基础

1. sessionStorage,localStorage,cookie 区别

- 都会在浏览器端保存，有大小限制，同源限制
- cookie 会在请求时发送到服务器，作为会话标识，服务器可修改 cookie；web storage 不会发送到服务器
- cookie 有 path 概念，子路径可以访问父路径 cookie，父路径不能访问子路径 cookie
- 有效期：cookie 在设置的有效期内有效，默认为浏览器关闭；sessionStorage 在窗口关闭前有效，localStorage 长期有效，直到用户删除
- 共享：sessionStorage 不能共享，localStorage 在同源文档之间共享，cookie 在同源且符合 path 规则的文档之间共享
- localStorage 的修改会促发其他文档窗口的 update 事件
- cookie 有 secure 属性要求 HTTPS 传输
- 浏览器不能保存超过 300 个 cookie，单个服务器不能超过 20 个，每个 cookie 不能超过 4k。web storage 大小支持能达到 5M

2. 为什么说 https 比 http 更安全？

HTTP通信使用明文、请求和响应不会对通信方进行确认、无法保护数据的完整性  
HTTPS基于HTTP协议，通过SSL或TLS提供加密处理数据、验证对方身份以及数据完整性保护，具有以下特点：
- 内容加密：采用混合加密技术，中间者无法直接查看明文内容
- 验证身份：通过证书认证客户端访问的是自己的服务器
- 保护数据完整性：防止传输的内容被中间人冒充或者篡改


3. DOM树的渲染过程

- 从 DOM 树的根节点遍历所有可见节点，不可见节点包括：
 script,meta这样本身不可见的标签。
- 被 css 隐藏的节点，如display: none
- 对每一个可见节点，找到恰当的 CSSOM 规则并应用
发布可视节点的内容和计算样式

4. HTTP request 报文结构是怎样的

- 首行是Request-Line包括：请求方法，请求 URI，协议版本，CRLF
- 首行之后是若干行请求头，包括general-header，request-header或者entity-header，每个一行以 CRLF 结束
- 请求头和消息实体之间有一个CRLF 分隔
- 根据实际请求需要可能包含一个消息实体 一个请求报文例子如下：

```
GET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1
Host: www.w3.org
Connection: keep-alive
Cache-Control: max-age=0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36
Referer: https://www.google.com.hk/
Accept-Encoding: gzip,deflate,sdch
Accept-Language: zh-CN,zh;q=0.8,en;q=0.6
Cookie: authorstyle=yes
If-None-Match: "2cc8-3e3073913b100"
If-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMT

name=qiu&age=25
```

5. HTTP response 报文结构是怎样的

- 首行是状态行包括：HTTP 版本，状态码，状态描述，后面跟一个 CRLF
- 首行之后是若干行响应头，包括：通用头部，响应头部，实体头部
- 响应头部和响应实体之间用一个 CRLF 空行分隔
- 最后是一个可能的消息实体 响应报文例子如下：

```
HTTP/1.1 200 OK
Date: Tue, 08 Jul 2014 05:28:43 GMT
Server: Apache/2
Last-Modified: Wed, 01 Sep 2004 13:24:52 GMT
ETag: "40d7-3e3073913b100"
Accept-Ranges: bytes
Content-Length: 16599
Cache-Control: max-age=21600
Expires: Tue, 08 Jul 2014 11:28:43 GMT
P3P: policyref="http://www.w3.org/2001/05/P3P/p3p.xml"
Content-Type: text/html; charset=iso-8859-1

{"name": "xiaoming", "age": 25}
```
#### CSS

1. flex布局常用的方式

flex-direction: column; row; column-reverse; row-reverse;  
justfiy-content: center; flex-start; flex-end; space-between; space-around;

2. rem布局原理

rem的本质是改变根元素的字体大小，实现子元素等比缩放

例如设置
```
html {
  font-size: 16px;
}
p {
  font-size: 2rem; // 实际为32px
}
```

我们获取屏幕宽度 clientWidth 后，给根元素 html 的 font-size 设置对应的比例，例如1% clientWidth，一般通过js在页面的document.ready、resize和屏幕旋转中设置。
```
document.documentElement.style.fontSize = document.documentElement.clientWidth / 100 + 'px';
```
如何把设计图单位转化为rem值？此处我们可以推出公式：

> rem尺寸 = 元素宽度/设计稿屏幕宽度 * n （n为依据屏幕宽度切分的rem份数）


3. css选择器都有哪些

- *通用选择器：选择所有元素，不参与计算优先级，兼容性 IE6+
- #X id 选择器：选择 id 值为 X 的元素，兼容性：IE6+
- .X 类选择器： 选择 class 包含 X 的元素，兼容性：IE6+
- X Y 后代选择器： 选择满足 X 选择器的后代节点中满足 Y 选择器的元素，兼容性：IE6+
- X 元素选择器： 选择标所有签为 X 的元素，兼容性：IE6+
- :link，:visited，:focus，:hover，:active 链接状态： 选择特定状态的链接元素，顺序 LoVe HAte，兼容性: IE4+
- X + Y 直接兄弟选择器：在X 之后第一个兄弟节点中选择满足 Y 选择器的元素，兼容性： IE7+
- X > Y 子选择器： 选择 X 的子元素中满足 Y 选择器的元素，兼容性： IE7+
- X ~ Y 兄弟： 选择X 之后所有兄弟节点中满足 Y 选择器的元素，兼容性： IE7+

4. link与@import的区别

- link是 HTML 方式， @import是 CSS 方式
- link最大限度支持并行下载，@import过多嵌套导致串行下载，出现FOUC
- link可以通过rel="alternate stylesheet"指定候选样式
- 浏览器对link支持早于@import，可以使用@import对老浏览器隐藏样式
- @import必须在样式规则之前，可以在 css 文件中引用其他文件  
总体来说：link 优于@import

5. 如何创建块级格式化上下文(block formatting context),BFC 有什么用

创建规则：
- 根元素
- 浮动元素（float不是none）
- 绝对定位元素（position取值为absolute或fixed）
- display取值为inline-block,table-cell, table-caption,flex, inline-flex之一的元素
- overflow不是visible的元素

作用：
- 可以包含浮动元素
- 不被浮动元素覆盖
- 阻止父子元素的 margin 折叠

6. 如何水平居中一个元素

- 如果需要居中的元素为常规流中 inline 元素，为父元素设置text-align: center;即可实现
- 如果需要居中的元素为常规流中 block 元素，1）为元素设置宽度，2）设置左右 margin 为 auto。
- 如果需要居中的元素为浮动元素，1）为元素设置宽度，2）position: relative;，3）浮动方向偏移量（left 或者 right）设置为 50%，4）浮动方向上的 margin 设置为元素宽度一半乘以-1
- 如果需要居中的元素为绝对定位元素，1）为元素设置宽度，2）偏移量设置为 50%，3）偏移方向外边距设置为元素宽度一半乘以-1


7. 如何竖直居中一个元素

- 父元素设置 display: flex，设置 justify-content: center;
- 父元素设置定位 position: relative; 子元素设置定位 position: absolute; top: 50%; margin-top: -1 * 子元素高度
- 对于单行文本的垂直居中，设置 line-height 等于 height 就可以

8. css有哪些继承属性

- 关于文字排版的属性如：font，word-break，letter-spacing，text-align，text-rendering，text-shadow，line-height等
- color
- visibility
- cursor

#### Javascript

1. 什么是函数声明提升，什么是变量提升

函数声明提升：函数声明语句将会被提升到外部脚本或者外部函数作用域的顶部，即如果函数被正确声明，可以在当前作用域顶部执行。

变量提升： JavaScript的所有变量在函数体内始终是有定义的，也就是说变量在声明之前已经可用，而变量赋值操作留在原来的位置。

2. let和const声明有什么好处

它们的好处是和之前的声明语法 var 比较，let 可以形成暂时性死区， let 声明的变量只能在当前的子作用域使用，而且不能重复声明。 const 声明的是当前作用域内的常量，是不允许改变和重新赋值的。

3. 你最常用的es6新特性是什么？

开放题：es6 新特性： 解构赋值，Promise，Proxy，Set数据结构等都可以

4. async有用过吗，在使用时有什么要点

 async 实质是 Promise 的一个语法糖，摒弃了之前 Promise.then() 的相关写法。帮助我们按照同步的方式处理异步的代码，async 返回的是一个 Promise，需要用 await 语法接收。

5. DOM 元素 e 的 e.getAttribute(propName)和 e.propName 有什么区别和联系

- e.getAttribute()，是标准 DOM 操作文档元素属性的方法，具有通用性可在任意文档上使用，返回元素在源文件中设置的属性
- e.propName 通常是在 HTML 文档中访问特定元素的特性，浏览器解析元素后生成对应对象（如 a 标签生成 HTMLAnchorElement），这些对象的特性会根据特定规则结合属性设置得到，对于没有对应特性的属性，只能使用 getAttribute 进行访问

6. 数组的常用方法有哪些

开放题： join, shift, unshift, concat, slice, splice,reverse等

7. 数组的 slice 和 splice 方法有什么区别

- slice(start,end)：方法可从已有数组中返回选定的元素，返回一个新数组，包含从start到end（不包含该元素）的数组元素。
- splice()：该方法向或者从数组中添加或者删除项目，返回被删除的项目。（该方法会改变原数组）

#### html

1. 什么是html语义化，列举常用的语义化标签

web 语义化是指通过 HTML 标记表示页面包含的信息，包含了 HTML 标签的语义化和 css 命名的语义化。 HTML 标签的语义化是指：通过使用包含语义的标签（如 h1-h6）恰当地表示文档结构 css 命名的语义化是指：为 html 标签添加有意义的 class，id 补充未表达的语义，如Microformat通过添加符合规则的 class 描述信息 为什么需要语义化：

- 去掉样式后页面呈现清晰的结构
- 盲人使用读屏器更好地阅读
- 搜索引擎更好地理解页面，有利于收录
- 方便团队项目的可持续运作及维护

2. img标签的 title 和 alt 属性有什么区别

- title是global attributes之一，用于为元素提供附加的 advisory information。通常当鼠标滑动到元素上的时候显示。
- alt是<img>的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。


#### 微信小程序

1. 小程序的rpx原理？

rpx 其实是小程序以 iphone6 的宽度750px为基准设置的一种 rem 单位。  
计算方式与 rem 的计算方式一致： 实际尺寸 = rpx设置尺寸 * ( 设备宽度 / 750 )

2. 小程序内的请求有什么限制？

需要基于https请求，同时在真实环境中，需要在小程序后台配置相关合法域名。


#### 前端工具

1. git如何进行版本回滚

回滚的命令：git reset 和 git revert
* git reset

回滚到之前提交的某个版本，恢复的是此版本前的commit

```
git reset --hard 版本号
```
* git revert
基于之前的某个版本创建一个新版本，同时保留该版本后面的版本，记录整个版本变动流程
```
git revert -n 版本号
git add 
git commit -m 
```

2. webpack

* webpack 的打包执行流程？

   从配置文件定义的模块列表开始，处理应用程序，从入口文件开始递归构建一个依赖图，然后将所有模块打包为少量的bundle，通常只有一个，可由浏览器加载。

* webpack 常见配置有哪些？

   publicPath： 打包后生成的基础路径  
   入口文件： entry  
   输出文件：output  
   loaders：转换类型的模块  
   plugins： 实现额外功能的插件  


#### 技术框架

#####  Vue

1. vue 生命周期有哪些？

beforeCreate, created, beforeMount, mounted, beforeUpdate, updated, beforeDestroy, destroyed

2. vue-router 有哪几种模式？

hash 模式和 history 模式

3. vue 的浏览器兼容性，为什么会存在此类兼容性问题？

vue 不兼容 ie9 以下版本，因为 vue 利用了 es5 的特性构建，而 ie8 及以下并不支持 es5

4. vue 为什么使用虚拟 dom 构建？

虚拟 dom 本质上是真实 dom 的映射。在现代浏览器中，真实 dom 的属性非常多，操作 dom 的开销是巨大的，优先构建虚拟 dom 可以在渲染前完成大量的 dom 操作，同时规避本应有的性能问题。

5. vue 的双向数据绑定是怎么实现的？

利用 Object.defineProperty() 来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。

#### 前端安全

1. 什么是XSS注入式攻击？如何预防？

对数据进行严格的输出编码，使得攻击者提供的数据不再被浏览器认为是脚本而被执行。放置在url中需要url编码，目前前端开发框架基本都默认提供了前端输出编码。其他设置如CSP HTTP Header，输入验证和开启浏览器XSS防御等都是可选项，严格意义上并不能防御XSS攻击，但是可以和输出编码共同协作实施纵深防御策略。

2. iframe存在什么风险，如何防范？

iframe中可以执行脚本但是可以设置sandbox安全属性，通过它对iframe的行为进行各种限制，充分实现最小权限原则。只需要在iframe中添加关键词：

```
<iframe sandbox src="..."></frame>
```

sandbox也提供了丰富的配置参数，可以进行细粒度的控制其行为：允许表单，弹出窗口，执行脚本等

#### 手写题

1. 数组去重

代码仅作参考：  
es6 版本快速去重：
```
function Uniq(arr) {
  let result = [ ...new Set(arr) ]
  return result
}
```

2. 数组交集
代码仅作参考：  
es6 版本求数组交集：
```
function intersect(arr1, arr2) {
  let set1 = new Set(arr1)
  let set2 = new Set(arr2)
  return arr1.filter(x => set2.has(x))
}
```

3. 数组扁平化

代码仅作参考：  
es6 版本数组扁平化：
```
function flat(arr) {
  while(arr.some(item => Array.isArray(item))) {
    arr = [].concat(...arr)
  }
  return arr
}
```