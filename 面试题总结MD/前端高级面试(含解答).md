### 高级前端面试

#### 计算机和浏览器

1. 页面的重绘和回流是什么？如何优化回流？

> reflow：元素的内容、结构。位置或尺寸发生了变化，需要重新计算样式和渲染树；
> repaint： 元素的改变只影响了节点的一些样式（背景色、边框颜色，文字颜色等），只需要应用新样式绘制此元素。
> 回流的成本高于重绘，一个子节点的回流往往导致子节点以及同级节点的回流。

优化回流:  
- 避免逐个修改节点样式，尽量一次性修改
- 使用DocumentFragment将需要多次修改的DOM元素缓存，最后一次性append到真实DOM中渲染
- 可以将需要多次修改的DOM元素设置display: none，操作完再显示。（因为隐藏元素不在render树内，因此修改隐藏元素不会触发回流重绘）
- 避免多次读取某些属性
- 将复杂的节点元素脱离文档流，降低回流成本

2. 如何优化首屏加载速度？

- 减少资源请求数量（内联亦或是延迟动态加载）
- 使CSS样式表尽早加载，减少@import的使用，因为需要解析完样式表中所有import的资源才会算CSS资源下载完
- 异步js：阻塞解析器的 JavaScript 会强制浏览器等待 CSSOM 并暂停 DOM 的构建，导致首次渲染的时间延迟

3. ssr 有没有用过，适合的场景？
ssr 是服务端渲染，目前前端经常用来优化首屏加载速度：  
首屏的渲染是node发送过来的html字符串，并不依赖于js文件，这就会使用户更快的看到页面的内容。尤其是针对大型单页应用，打包后文件体积比较大，普通客户端渲染加载所有所需文件时间较长，首页就会有一个很长的白屏等待时间


#### CSS

1. 移动端浏览器的一像素显示问题如何解决？

- 设置合理的 viewport + rem 页面头部引入

```
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">  
<meta name="viewport" id="WebViewport" content="initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"> 
```
同时用 js 动态改变缩放比 
```
var viewport = document.querySelector("meta[name=viewport]")
if (window.devicePixelRatio == 1) {
    viewport.setAttribute('content', 'width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no')
} 
if (window.devicePixelRatio == 2) {
    viewport.setAttribute('content', 'width=device-width, initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no')
} 
if (window.devicePixelRatio == 3) {
    viewport.setAttribute('content', 'width=device-width, initial-scale=0.333333333, maximum-scale=0.333333333, minimum-scale=0.333333333, user-scalable=no')
} 

var docEl = document.documentElement;
var fontsize = 10 * (docEl.clientWidth / 320) + 'px';
docEl.style.fontSize = fontsize;
```
- 使用 transform: scale 实现缩放规避此问题

2. css hack 是什么，用来解决什么问题？

CSS hack是通过在CSS样式中加入一些特殊的符号，让不同的浏览器识别不同的符号（什么样的浏览器识别什么样的符号是有标准的，CSS hack就是让你记住这个标准），以达到应用不同的CSS样式的目的。常用来解决一些历史兼容性问题（兼容ie 6，7）

#### Javascript

1. js事件执行机制模型

js是单线程语言

- 主线程执行的时候产生栈和堆，栈中的代码负责调用各种api，在任务队列中假如事件(click, load, done)，只要栈中的代码执行完毕后，就会去读取任务队列，依次执行那些事件所对应的回调函数。

- 同步任务直接进入主线程执行，如果是异步的，不进入主线程、而进入"任务队列"的任务，只要"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。主线程从“任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为 事件循环。

2. 简述 es6 的 Promise  

可以将 promise 看做一个状态机，初始为 pending 状态，可以通过函数 resolve 和 reject ,将状态机变为 resolved 或者 rejected 状态，状态一旦改变无法再次发生变化。

then 函数会返回一个 Promise 实例，并且该返回值是一个新的实例而不是之前的实例。因为 Promise 规范规定除了 pending 状态，其他状态是不可改变的，如果返回一个相同实例，多个 then 调用就毫无意义了。

3. 什么是闭包，闭包为什么会引发内存泄漏？

在js中，闭包对应的就是函数--常见--能够读取其他函数内部变量的函数  

内存泄漏：由于疏忽或错误造成程序未能释放已经不再使用的内存。闭包创建的函数不会被回收，处于随时被调用状态，过度使用会导致内存占用过多引发内存泄漏。

4. 简述 ES6 迭代器（遍历器）

ES6 规定，默认的 Iterator 接口部署在数据结构的 Symbol.iterator 属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。Symbol.iterator 属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。

5. ES6 Module 与 CommonJS 的区别  

CommonJS规范在Node中发扬光大，它有以下特性：
- 动态加载模块：CommonJS模块的动态加载能轻松实现懒加载
- 加载整个模块：CommonJS模块中，导出的是整个模块
- 每个模块皆为对象：CommonJS模块都被视为一个对象
- 值拷贝：CommonJS模块输出和函数的值传递相似，都是值的拷贝

ES6模块：
- 静态解析：在解析阶段就确定输出的模块，所以 es6 模块的 import 一般写在引入文件的开头
- 模块不是对象：在es6模块中，每个模块并不会当作一个对象看待
- 加载的不是整个模块：在es6模块中经常会有多个export导出
- 模块引用：es6模块中，导出的并不是模块的值拷贝，而是这个模块的引用


#### 微信小程序

1. 小程序的页面栈的 redirectTo 方法有用过吗, 需要注意哪些问题？

redirectTo是页面的重定向跳转方法，但是实际使用中需要注意此方法导致的同一页面栈重复加载问题：假设有 a 和 b 两个页面，我们想要从 a 跳转 b 再从 b 跳转回 a； 如果 b 跳转 a 用的是 redirectTo 方法，小程序的页面栈中会出现一个新的 b 页面，这样会 b 页面数据不一致的问题，所以应当避免使用 redirectTo 回跳原页面，此时合理的做法是用 navigateBack 返回 a

2. 小程序 cover-view 如何设置显示隐藏

小程序暂不支持通过 wx:if 控制显隐，但是可以通过控制透明度控制显示隐藏

3. 小程序的缺陷

开放题：围绕 storage ，原生组件支持，页面栈问题讨论


#### 前端工具

1. webpack 中 plugin 和 loader 的区别，你都用过哪些

loader 被用于转换某些类型的模块，执行特定的任务，例如 css-loader，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。插件目的在于解决 loader 无法实现的其他事。

2. webpack打包如何优化

核心思路是用最少的资源做相同的事情：  
- 减小文件搜索范围
- 增强代码压缩工具：采用 webpack-parallel-uglify-plugin 插件，可以并行运行 UglifyJS 插件
- 用 Happypack 来加速代码构建
- 设置 babel 的 cacheDirectory 为true
- 设置 noParse


#### 前端安全和项目优化

1. 前端如何防范存放在CDN的静态资源被劫持？

静态资源存放在CDN中，如果CDN被劫持会有安全问题。我们可以浏览器提供的SRI（Subresource Integrity）功能，给静态资源文件SRI值。浏览器在处理这个script元素时，就会检查对应js脚本的完整性。如果sri不匹配，浏览器就中止对这个js脚本的处理。

2. 前端优化有哪些方向，你做过哪些实践？

开放题：围绕浏览器，网络请求，打包部署工具，团队协作都可以展开讨论。

#### 技术框架

#####  Vue

1. Vue 的数据改变，一定会触发页面改变吗？什么样的监听不到，出现这种问题的原因是什么，怎么解决？

2. Vue 组件之间传值有哪些方法，父子，非父子？

3. Vue中的自定义指令如何使用？

4. vue.$nextTick用来处理哪类问题？

5. vue 和 react 有哪些相同和不同？

#### 手写题

1. 实现一个方法，解析浏览器地址栏并返回一个对象
代码仅作参考：
```
function resolveURL(url) {
    let args = url.split('?')[1].split('&'),
    obj = {},
    tmpName,
    tmpValue;
    for (let i = 0; i < args.length; i++) {
        [tmpName, tmpValue] = args[i].split('=');
        obj[tmpName] = tmpValue
    }

    return obj;
}
```

2. 以下代码的输出（ promise 和 async 输出顺序）(考查js事件机制)

```
console.log("start");

setTimeout(() => {
  console.log("setTimeout");
}, 0);

new Promise((resolve) => {
  resolve();
})
.then(() => {
  return console.log("A1");
})
.then(() => {
  return console.log("A2");
});

new Promise((resolve) => {
  resolve();
})
.then(() => {
  return console.log("B1");
})
.then(() => {
  return console.log("B2");
})
.then(() => {
  return console.log("B3");
});

console.log("end");
```
输出
// start 
// end
// A1
// B1
// A2
// B2
// B3

3. 实现一个类似红绿灯的功能，让一个div按照黄色1秒，红色2秒，绿色3秒的规律持续变换背景色  
代码仅作参考：
```
function light(duration, color) {
  return new Promise((res, rej) => {
      setTimeout(res, duration)
  })
}
async function changeLight() {
  let lightEle = document.querySelector('#light')
  while(true) {
    lightEle.style.backgroundColor = 'green'
    await light(3000)
    lightEle.style.backgroundColor = 'yellow'
    await light(1000)
    lightEle.style.backgroundColor = 'red'
    await light(2000)
  }
}
```